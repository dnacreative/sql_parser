<?php
// $Id: sql_converter.inc,v 1.7 2010/06/22 23:00:28 duellj Exp $

/**
 * @file
 */

/**
 * Sql Converter
 *
 * Takes a parsed sql array and converts it into a DBTNG object string.
 */
class SqlConverter {
  /**
   * The sql object generated by SqlParser.
   *
   * @param SqlObject $sql_object;
   */
  protected $sql_object;

  /**
   * The arguments used to replace placeholder fields.
   *
   * @param array $arguments
   */
  protected $arguments;

  protected $output = array();

  public function __construct(SqlObject $sql_object) {
    $this->sql_object = $sql_object;
  }

  /**
   * Sets the query arguments.
   *
   * Any placeholders within the SQL statement correspond to arguments on a
   * sequential basis, i.e. the first placeholder found (usually within the
   * conditionals) will correspond to the first element in the arguments
   * array.
   *
   * @param $arguments
   *   An array of placeholder arguments.
   */
  public function setQueryArguments($arguments) {
    $this->arguments = $arguments;
  }

  /**
   * Perform conversion.
   */
  public function convert() {
    switch ($this->sql_object->command) {
      case 'select':
        $this->convertSelect();
        break;

      case 'insert':
        $this->convertInsert();
        break;

      case 'update':
        $this->convertUpdate();
        break;

      case 'delete':
        $this->convertDelete();
        break;
    }
    $this->output[] = "  ->execute()";

    return join("\n", $this->output);
  }

  /**
   * Convert select query.
   */
  protected function convertSelect() {
    // Add first table to db_select() function.
    $this->output[] = "db_select('" . $this->sql_object->tables[0]->name . "', '" . $this->getTableAlias(0) . "')";

    $this->convertSelectFields();

    if (count($this->sql_object->tables) > 1) {
      $this->convertJoins();
    }

    if ($this->sql_object->conditional) {
      $this->convertConditionals($this->sql_object->conditional);
    }

    if ($this->sql_object->group_by_clause) {
      foreach ($this->sql_object->group_by_clause->columns as $group_by_column) {
        $this->output[] = "  ->groupBy($group_by_column)";
      }

      if ($this->sql_object->having_clause) {
        $this->convertHaving($this->sql_object->having_clause);
      }
    }

    if ($this->sql_object->order_by) {
      foreach ($this->sql_object->order_by as $order) {
        $this->output[] = "  ->orderBy('" . $order->column . "', '" . $order->direction . "')";
      }
    }

    if ($this->sql_object->limit) {
      $this->output[] = "  ->range(" . $this->sql_object->limit->offset . ', ' . $this->sql_object->limit->row_count . ")";
    }
  }

  /**
   * Convert insert query.
   */
  protected function convertInsert() {
    $this->output[] = '$id = db_insert(\'' . $this->sql_object->tables[0]->name . '\')';
    $this->convertFields();
  }

  /**
   * Convert update query.
   */
  protected function convertUpdate() {
    $this->output[] = "db_update('" . $this->sql_object->tables[0]->name . "')";

    $this->convertFields();

    if ($this->sql_object->conditional) {
      $this->convertConditionals($this->sql_object->conditional);
    }

    if ($this->sql_object->order_by) {
      foreach ($this->sql_object->order_by as $order) {
        $this->output[] = "  ->orderBy('" . $order->column . "', '" . $order->direction . "')";
      }
    }

    if ($this->sql_object->limit) {
      $this->output[] = "  ->range(" . $this->sql_object->limit->offset . ', ' . $this->sql_object->limit->row_count . ")";
    }
  }

  /**
   * Convert delete query.
   */
  protected function convertDelete() {
    $this->output[] = "db_delete('" . $this->sql_object->tables[0]->name . "')";

    if ($this->sql_object->conditional) {
      $this->convertConditionals($this->sql_object->conditional);
    }
  }

  /**
   * Convert Select query fields.
   */
  protected function convertSelectFields() {
    // Select all fields.
    if ($this->sql_object->fields[0]->name == '*') {
      $this->output[] = "  ->fields()";
    }
    // Select individual fields.
    else {
      // Group fields by table.  If no table is set for a field, then use the first table.
      // If field has an alias, then the field needs to be grouped individually.
      $table_fields = array();
      $aliased_fields = array();
      foreach ($this->sql_object->fields as $id => $field) {
        if ($field->alias) {
          $aliased_fields[] = $field;
        }
        else {
          if ($field->table) {
            $table_fields[$field->table][] = $field->name;
          }
          else {
            $table_fields[$this->sql_object->tables[0]->alias][] = $field->name;
          }
        }
      }

      // Add fields for each table.
      if ($table_fields) {
        foreach ($table_fields as $table_alias => $fields) {
          $this->output[] = "  ->fields('$table_alias', array('" . join("', '", $fields) . "'))";
        }
      }

      // Add aliased fields.
      if ($aliased_fields) {
        foreach ($aliased_fields as $field) {
          if (!($table_alias = $field->table)) {
            $table_alias = $this->sql_object->tables[0]->alias;
          }
          $this->output[] = "  ->addField('$table_alias', '" . $field->name . "', '" . $field->alias . "')";
        }
      }
    }
  }

  /**
   * Convert Insert and Update query fields.
   */
  protected function convertFields() {
    $this->output[] = "  ->fields(array(";
    foreach ($this->sql_object->columns as $column) {
      if ($column->type == 'placeholder') {
        $value = array_shift($this->arguments);
      }
      else {
        $value = $column->value;
      }
      $this->output[] = "    '" . $column->name . "' => " . $value . ",";
    }
    $this->output[] = "  ))";
  }

  /**
   * Convert table joins.
   */
  function convertJoins() {
    foreach ($this->sql_object->tables as $key => $table) {
      // Only convert tables that have a join.
      if ($table->join) {
        switch ($table->join) {
          case 'join':
          case 'inner join':
            $join_statement = "  ->join(";
            break;

          case 'left join':
            $join_statement = "  ->leftJoin(";
            break;

          case 'right join':
            $join_statement = "  ->rightJoin(";
            break;
        }
        $right_table_alias = $this->getTableAlias($key + 1);
        $left_table_alias = $this->getTableAlias($key);

        $join_statement .= "'" . $table->name . "', ";
        $join_statement .= "'" . $right_table_alias . "', ";

        // Add join condition.
        if ($table->join_conditional->type == 'using') {
          $join_conditions = array();
          foreach ($table->join_conditional->columns as $column) {
            $join_conditions[] = $left_table_alias . '.' . $column . ' = ' . $right_table_alias . '.' . $column;
          }
          $join_statement .= "'" . join(' AND ', $join_conditions) . "'";
        }
        else {
          // @todo: extract table names to assign the correct table alias to fields.
          // @todo: check if args are placeholders.
          $join_statement .= "'" . $join_condition['arg_1']['value'] . " " . $join_condition['op'] . " " . $join_condition['arg_2']['value'] . "'";
        }

        $join_statement .= ")";

        $this->output[] = $join_statement;
      }
    }
  }

  /**
   * Transform parsed sql into conditional object strings.
   *
   * @param SqlConditional $conditionals
   *   Parsed conditional object.
   * @param $level
   *   Level of conditional statements.
   */
  protected function convertConditionals(SqlConditional $conditional, $level = 1) {
    $closing_parenthesis = FALSE;

    // Convert operator.
    switch ($conditional->operator) {
      case 'and':
        if ($level > 1) {
          $this->output[] = str_repeat("  ", $level - 1) . "->condition(db_and()";
          $closing_parenthesis = TRUE;
        }
        break;
      case 'or':
        $this->output[] = str_repeat("  ", $level - 1) . "->condition(db_or()";
        $closing_parenthesis = TRUE;
        break;
      case 'xor':
        $this->output[] = str_repeat("  ", $level - 1) . "->condition(db_xort()";
        $closing_parenthesis = TRUE;
        break;
    }

    // Convert conjunction.
    if (in_array($conditional->operator, array('and', 'or', 'xor'))) {
      $this->convertConditionalFragment($conditional->arg1, $level);
      $this->convertConditionalFragment($conditional->arg2, $level);
    }
    // Convert single conditional fragment.
    else {
      $this->convertConditionalFragment($conditional, $level);
    }

    if ($closing_parenthesis) {
      $this->output[] = str_repeat("  ", $level - 1) . ")";
    }
  }

  /**
   * Transform conditional fragment into conditional object string.
   *
   * If conditional fragment is a subclause, pass it back to
   * coder_upgrade_convert_conditional.
   *
   * @param SqlConditional $conditionals
   *   Parsed conditional object.
   * @param $level
   *   Level of conditional statements.
   *
   * @return
   *   Array of conditional object string.
   */
  protected function convertConditionalFragment(SqlConditional $conditional, $level = 1) {
    if ($conditional->arg1 instanceof SqlConditional) {
      // Arg1 is conditional, pass back to convertConditional().
      $this->convertConditionals($conditional->arg1, $level + 1);
    }
    else {
      $output = str_repeat("  ", $level) . "->condition('" . $conditional->arg1;

      // Determine the correct arg2 for the conditional
      if ($conditional->arg2->type == 'placeholder') {
        $value = array_shift($this->arguments);

        // IN operator now just takes an array, rather than imploded array.
        if ($conditional->operator == 'in' && preg_match("/db_placeholders\(([^,]*).*\)/", $value, $matches)) {
          $value = $matches[1];
        }
      }
      elseif ($conditional->operator == 'in' && is_array($conditional->arg2)) {
        $value = 'array(' . join(', ', $conditional->arg2) . ')';
      }
      else {
        $value = $conditional->arg2->name;
      }
      $output .=  "', $value";

      // Add operator if necessary.
      if ($conditional->operator != '=') {
        $output .= ", '" . $conditional->operator . "'";
      }

      $output .= ")";

      $this->output[] = $output;
    }
  }

  /**
   * Transform parsed having sql into having object strings.
   *
   * @param SqlHavingClause $having
   *   Parsed having object.
   * @param $values
   *   Placeholder values.
   * @param $level
   *   Level of having statements.
   *
   * @todo Refactor with convertCondtionals().
   */
  protected function convertHaving($having, &$values, $level = 1) {
    $closing_parenthesis = FALSE;

    // Convert operator.
    switch ($havings['op']) {
      case 'and':
        if ($level > 1) {
          $this->output[] = str_repeat("  ", $level - 1) . "->havingCondition(db_and()";
          $closing_parenthesis = TRUE;
        }
        break;
      case 'or':
        $this->output[] = str_repeat("  ", $level - 1) . "->havingCondition(db_or()";
        $closing_parenthesis = TRUE;
        break;
      case 'xor':
        $this->output[] = str_repeat("  ", $level - 1) . "->havingCondition(db_xort()";
        $closing_parenthesis = TRUE;
        break;
    }

    // Convert conjunction.
    if (in_array($havings['op'], array('and', 'or', 'xor'))) {
      $this->convertHavingFragment($havings['arg_1'], $values, $level);
      $this->convertHavingFragment($havings['arg_2'], $values, $level);
    }
    // Convert single conditional fragment.
    else {
      $this->convertHavingFragment($havings, $values, $level);
    }

    if ($closing_parenthesis) {
      $this->output[] = str_repeat("  ", $level - 1) . ")";
    }
  }

  /**
   * Transform having fragment into conditional object string.
   *
   * @param $havings
   *   Parsed having object.
   * @param $values
   *   Placeholder values.
   * @param $level
   *   Level of conditional statements.
   *
   * @return
   *   Array of having object string.
   *
   * @todo Refactor with convertConditionalFragment
   */
  protected function convertHavingFragment($fragment, &$values = array(), $level = 1) {
    // If arg_1 or arg_2 is a function, then we have to use the having() function.
    if ($fragment['arg_1']['type'] == 'function' || $fragment['arg_2']['type'] == 'function') {
      $output = str_repeat("  ", $level) . '->having("';
      $output .= $this->formatArg($fragment['arg_1']);
      $output .= ' ' . $fragment['op'] . ' ';
      $output .= $this->formatArg($fragment['arg_2']);
      $output .= '")';
    }
    else {
      $output = str_repeat("  ", $level) . "->havingCondition('" . $fragment['arg_1']['value'];
      if ($fragment['arg_2']['type'] == 'placeholder') {
        $value = array_shift($values);

        // IN operator now just takes an array, rather than imploded array.
        if ($fragment['op'] == 'in' && preg_match("/db_placeholders\(([^,]*).*\)/", $value, $matches)) {
          $value = $matches[1];
        }
      }
      else {
        $value = "'" . $fragment['arg_2']['value'] . "'";
      }
      $output .=  "', $value";

      // Add operator if necessary.
      if ($fragment['op'] != '=') {
        $output .= ", '" . $fragment['op'] . "'";
      }

      $output .= ")";
    }
    $this->output[] = $output;
  }

  /**
   * Get a table alias.
   *
   * If a table alias isn't already set, then generate one.
   *
   * @param $table_key
   *   The key of the table in the parsed sql array.
   *
   * @return
   *   The alias of the table name.
   */
  function getTableAlias($table_key) {
    if (!($alias = $this->sql_object->tables[$table_key]->alias)) {
      $alias = $this->generateTableAlias($table_key);
    }
    return $alias;
  }

  /**
   * Generate table alias.
   *
   * Usually the first letter of each word of the table
   * name (e.g. `n` for * `node` or `nr` for `node_revisions`).
   * If an alias is taken, then increments alias.
   *
   * @param $table_key
   *   The key of the table in the parsed sql array.
   *
   * @return
   *   The alias of the table name.
   */
  protected function generateTableAlias($table_key) {
    // Generate new table alias based on table name.
    $table_name = $this->sql_object->tables[0]->name;
    $table_words = explode('_', $table_name);
    foreach ($table_words as $table_word) {
      $alias .= $table_word[0];
    }

    // Get all current table aliases
    $table_aliases = array();
    foreach ($this->parsed_sql->tables as $table) {
      if ($table->alias) {
        $table_aliases[] = $table->alias;
      }
    }

    // Check if table alias already exists
    $original_alias = $alias;
    $i = 0;
    while (in_array($alias, $table_aliases)) {
      $alias = $original_alias . ++$i;
    }

    // Set table alias to generated alias
    $this->sql_object->tables[$table_key]->setAlias($alias);
    return $alias;
  }

  /**
   * Format field or argument into a string.
   *
   * Tests if a field or argument is a function, and if so, flattens function
   * into a string.
   *
   * @param $arg
   *   The parsed arg array to format.
   *
   * @return
   *   The formatted string.
   */
  function formatArg($arg) {
    if ($arg['type'] == 'function') {
      $output = $arg['value']['name'] . "(" . join(', ', $arg['value']['arg']) . ")";
    }
    else {
      $output = $arg['value'];
    }
    return $output;
  }
}
